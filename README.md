# sokoban-versus
推箱子双人对战

## 接口示例

调用方法: HTTP (POST)
URI: /api/run
请求header描述: Content-Type: application/json
输入参数
```json
{
  参考请求输入body参数
}
```

请求输入body参数:

序号 | 属性英文名称 | 属性中文名称 | 字符类型 | 取值范围及说明
---|---|---|---|---
1 | uid | 地图ID | String | 每局比赛唯一地图ID
2 | side | 选手位置 | Int | 1: 左方人员 2: 右方人员
3 | row | 地图行数 | Int |
4 | column | 地图列数 | Int |
5 | map | 地图信息 | Array[][] | 代表地图的一个二维数组, 每个元素都是一个正整数, 代表的含义分别为: 0-空白位置, 1-左方人员, 2-右方人员, 3-箱子, 4-障碍物

请求消息体示例
```json
{"uid":"ef869456232","side":1,"row":15,"column":15,"map":[[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],[4,1,0,0,0,0,0,0,0,0,0,0,0,2,4],[4,0,0,0,0,3,0,0,0,0,0,0,0,0,4],[4,0,0,4,0,0,0,0,0,0,0,3,0,0,4],[4,0,0,0,3,0,0,0,0,4,0,0,0,0,4],[4,0,0,0,0,0,0,0,0,4,0,3,0,0,4],[4,0,0,3,0,0,0,0,0,0,0,0,0,0,4],[4,1,0,0,0,0,0,4,0,0,0,0,0,2,4],[4,0,0,0,0,0,0,0,0,0,0,3,0,0,4],[4,0,0,3,0,4,0,0,0,0,0,0,0,0,4],[4,0,0,0,0,4,0,0,0,0,3,0,0,0,4],[4,0,0,3,0,0,0,0,0,0,0,4,0,0,4],[4,0,0,0,0,0,0,0,0,3,0,0,0,0,4],[4,1,0,0,0,0,0,0,0,0,0,0,0,2,4],[4,4,4,4,4,4,4,4,4,4,4,4,4,4,4]]}
```

响应参数
```json
{
  参考响应body参数
}
```

响应body参数:

英文名称 | 字符类型 | 描述
direction | Int | 移动方向, 0-上, 1-下, 2-左, 3-右
position | Array | 移动人员位置, 一维数组, 表示当前需要移动的人员在地图上的坐标位置

响应消息体示例
```json
{
    "direction":1,
    "position":[5,2]
}
```

## 地图信息

地图大小: 15 * 15 (备注: 去掉边界后实际大小为 13 * 13)
障碍数量: 7
箱子数量: 10 (先推完5个者获胜)
最大回合数: 120
胜局数: 3局2胜利
接口最大响应时间: 300ms (超时则判定为无效指令)


## 比赛规则详细解读

1. 地图

地图是一个有15行15列的矩形区域, 一共有15*15格, 地图的边界均为障碍物(值为4), 选手无法移动到边界之外的位置. 地图内部包含空白位置(值为0), 选手人员(值为1或2), 箱子(值为3)和障碍物(值为4).
每个位置只能有一种元素存在, 不能同时有多个内容. 例如2个人员在一个格子内, 是不可能的.

2. 人员

虽然地图是随机的, 然而双方的3个人员的初始位置是固定的. 分别在最左侧、最右侧的上、中、下三个固定位置.
一方在一个回合内最多能指定1个人员进行移动. 当然也可以不指定(相当于放弃本回合移动机会).
人员可以向上、下、左、右四个方向移动1格. 不支持斜方向移动.
一个回合只能沿着移动方向移动一个格子.
如果一方提交的移动方向被对战平台认为不可行(例如, 某方想将某人员移动到障碍物位置), 该回合结束后, 此人员将维持在原地. 对战平台并不会给该方在本轮内重新提交的机会.

3. 箱子

箱子初始呈随机分布. 但是这个初始分布也是有基本规律的:
- 呈180度旋转对称
- 一行只有一个箱子
- 人员所在的行(即最上/最下/中间 3行) 没有箱子
- 所以箱子数量 = 行数 - 人员数 = 行数 - 3

箱子本身不会移动, 只有靠人员推动才可以移动. 人在移动过程中, 旁边有箱子, 即可形成"推动". 其结果是: 箱子沿着人移动的方向移动一格. 人也移动一格.

箱子的目的地是: 最左方列或者最右方列. 箱子进入最左侧列视作右方得分, 进入最右侧列视作左方得分. 无论这个箱子是哪方推入的.

箱子进入目的地后, 仍然可以被移动(例如上下移动). 但显然, 进入目的地的箱子总归是无法逃离目的地的.

4. 障碍物

障碍初始呈随机分布. 但是这个初始分布也是有基本规律的:
- 呈180度旋转对称
- 一行的障碍物最多只有一个. 障碍数不会多于行数.

在一场比赛内, 障碍点不会再发生变更(新增/删除/移动), 永久有效. 障碍个数由对战平台指定.

4. 回合

这里的回合制和"下棋"不同. 下棋分先后手, 先手走一步, 后手走一步, 交替执行.

推箱子比赛不分先后手, 一个回合内双方同时执行, 将结果交给对战平台判定. 判定后进入下一回合.

每一回合内, 对参赛选手的算法响应时间有限制, 超过时间限制则视作无效指令(即该方本回合不移动任何人员).

如果双方程序过强或者过弱, 有可能任何一方都不能在有限时间内把半数的箱子推至目的地. 为了避免对战平台陷入无穷运转, 每轮比赛有最大回合数的设定. 每轮比赛最多运行最大回合数后停止.

## 规则判定

1. 比赛判定过程

对战平台收到双方提交的出招后, 进行判定的过程是: 先做"无效出招"过滤, 再做相容性判断.

1.1 无效出招过滤

以下出招被认定为"无效出招":
- 出招所指定的人员不是己方人员
- 出招所指定的人员移动方向不是上/下/左/右四个方向之一
- 出招所指定的人员移动后, 位置超出地图边界
- 出招所指定的人员移动后, 位置为障碍物所在位置
- 出招所指定的人员推动箱子后, 箱子位置超出地图边界
- 出招所指定的人员推动箱子后, 箱子位置为障碍物所在位置

无效出招将被事先过滤掉, 视为该方本回合不移动任何人员.

1.2 相容性判断

先看一个例子:
左方出招: 将人员向右移动. 而右侧正被右方人员占据, 但这并不是"无效出招".
理由是: 右方人员可能在此回合离开这个格子, 最终结果可能是"相容"的.

平台对相容性判断的过程是:
1. 将地图中的出招涉及的源的位置腾空(源有人、箱子两种)
2. 计算各个源的目标位置, 再将源放置在目标位置上. 如果不发生冲突即为相容.

这里说的"冲突", 即"不相容", 有3种:
- 基本冲突: 目的地被放置多个物件
- 源冲突: 将某个源移至多个格子
- 目的冲突: 将多个源移至同一格子

2. 胜负判定

a. 一方把1个箱子推到本方目的地, 记录1分. 总分即为箱子数X. 一方得分先达到X/2即为胜利. 如果双方同时达到得分X/2, 进入c.
b. 最大回合数是MAX. 在MAX回合结束时得分较多的一方获胜. 如果得分相同, 进入c.
c. 双方得分相同. 此时判断场面上的"箱子远离度", 箱子远离度高的一方获胜. 如果还是一样多, 进入d.
箱子远离度: 每个箱子距离本方出发列的横向距离总和.
出发列指的是本方人员出发列, 即最左列或者最右列, 不是箱子的初始位置所在列.
d. 双方箱子远离度也相同. 此时判断场面上的"人员远离度", 人员远离度高的一方获胜. 如果相同, 进入e.
人员远离度: 每个己方人员距离本方出发列的横向距离总和.
e. 双方人员远离度也相同. 此时由曾经先完成箱子数的一方获胜. 也就是说平台会进行回溯, 看哪方先完成了X/2个箱子. 如果还是相同, 则进入f.
f. 计算比赛双方的算法总的耗时, 总耗时时间短的获胜, 时间计算精确到毫秒.
